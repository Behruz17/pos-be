# Система контроля доступа (RBAC)

## Обзор

Система реализует многоуровневый контроль доступа на основе ролей (Role-Based Access Control) с привязкой пользователей к магазинам.

## Роли пользователей

### Администратор (ADMIN)
- **Права доступа**: Полный доступ ко всем магазинам и данным системы
- **Ограничения**: Нет
- **Особенности**:
  - Может создавать/редактировать/удалять любые данные
  - Может управлять пользователями и назначать им магазины
  - Может просматривать отчеты по всем магазинам

### Пользователь (USER)
- **Права доступа**: 
  - Полный доступ только к своему магазину (store_id)
  - Read-only доступ к данным других магазинов
- **Ограничения**:
  - Все операции автоматически ограничены их магазином
  - Не могут создавать пользователей
  - Не могут изменять настройки системы
- **Особенности**:
  - Могут просматривать данные других магазинов в режиме чтения
  - Автоматически привязаны к конкретному магазину

## Требования к базе данных

### Обязательная миграция
Для работы системы контроля доступа необходимо выполнить миграцию:
```sql
-- Выполнить содержимое файла: migration_add_store_id_to_users.sql
```

### Структура таблицы users
```sql
ALTER TABLE `users` 
ADD COLUMN `store_id` int NULL AFTER `role`;

ALTER TABLE `users` 
ADD CONSTRAINT `fk_users_store` 
FOREIGN KEY (`store_id`) REFERENCES `stores` (`id`) ON DELETE SET NULL;

ALTER TABLE `users` 
ADD INDEX `idx_store_id` (`store_id`);
```

## Реализация в коде

### Middleware

#### authMiddleware
Базовая аутентификация пользователя:
- Проверяет наличие и валидность токена
- Получает информацию о пользователе из базы данных
- Добавляет `req.user` с данными пользователя (включая `store_id`)

#### authorizeStoreAccess(allowReadOnly = false)
Контроль доступа на уровне магазинов:
- **Для администраторов**: предоставляет полный доступ
- **Для пользователей**:
  - Проверяет наличие `store_id` у пользователя
  - Сравнивает запрашиваемый магазин с магазином пользователя
  - При `allowReadOnly = true` позволяет ограниченный доступ к другим магазинам
  - При `allowReadOnly = false` блокирует доступ к чужим магазинам

### Примеры использования

```javascript
// Только аутентификация (для общедоступных данных)
app.get('/api/public/data', authMiddleware, (req, res) => { ... });

// Полный контроль доступа (только свой магазин)
app.post('/api/sales', authMiddleware, authorizeStoreAccess(false), (req, res) => { ... });

// Частичный контроль доступа (с read-only доступом к другим)
app.get('/api/customers', authMiddleware, authorizeStoreAccess(true), (req, res) => { ... });
```

## API изменения

### Новые обязательные поля

#### POST /api/auth/register
```json
{
  "login": "string",
  "password": "string", 
  "name": "string",
  "role": "USER", // или "ADMIN"
  "store_id": 1     // Обязательно для USER, опционально для ADMIN
}
```

#### Ответы с user data теперь включают:
```json
{
  "id": 1,
  "login": "username",
  "name": "User Name",
  "role": "USER",
  "store_id": 1,
  "created_at": "2023-01-01T00:00:00.000Z"
}
```

## Безопасность

### Защита от несанкционированного доступа
- Все эндпоинты требуют действительного токена
- USER-пользователи не могут получить доступ к данным чужих магазинов в режиме записи
- Администраторы имеют полный контроль, но логгируются все действия

### Валидация данных
- Проверка существования магазина при назначении пользователю
- Автоматическое ограничение операций по store_id для USER-пользователей
- Валидация входных данных на уровне API

## Тестирование

### Рекомендуемые сценарии тестирования

1. **Администраторский доступ**
   - [ ] Администратор может получить доступ ко всем магазинам
   - [ ] Администратор может создавать пользователей
   - [ ] Администратор может назначать store_id

2. **Пользовательский доступ**
   - [ ] USER может получить доступ только к своему магазину
   - [ ] USER не может создавать данные в чужом магазине
   - [ ] USER получает ограниченный доступ к другим магазинам при read-only

3. **Ограничения**
   - [ ] USER без store_id не может выполнять операции
   - [ ] Невалидные store_id блокируются
   - [ ] Попытки обхода ограничений логгируются

## Мониторинг и логирование

### Рекомендуемые метрики
- Количество попыток несанкционированного доступа
- Частота использования read-only доступа
- Активность администраторов
- Ошибки контроля доступа

## Часто задаваемые вопросы

### Q: Что делать, если USER-пользователь не имеет store_id?
**A:** Такие пользователи не смогут выполнять операции с данными. Администратор должен назначить им магазин через обновление записи в базе данных.

### Q: Можно ли изменить store_id у существующего пользователя?
**A:** Да, но только администратор может это сделать через прямое обновление в базе данных или через API управления пользователями.

### Q: Как реализован read-only доступ?
**A:** Через middleware `authorizeStoreAccess(true)`, который устанавливает флаг `req.readOnlyAccess` для последующей фильтрации данных на уровне приложения.

## Обратная совместимость

Система разработана с учетом обратной совместимости:
- Существующие администраторы продолжают работать как прежде
- Для USER-пользователей требуется миграция базы данных
- API-эндпоинты с новыми полями поддерживают старые форматы запросов

## Поддержка

При возникновении проблем с доступом:
1. Проверьте наличие store_id у USER-пользователей
2. Убедитесь, что выполнена необходимая миграция
3. Проверьте логи сервера на наличие ошибок контроля доступа